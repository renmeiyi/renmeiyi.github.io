<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>RabbitMQ笔记</title>
      <link href="/2025/04/04/RabbitMQ/"/>
      <url>/2025/04/04/RabbitMQ/</url>
      
        <content type="html"><![CDATA[<h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><p>分布式消息中间件。</p><p>其他还要负载均衡中间件：nginx，缓存中间件：redis，数据库中间件：Mycat等</p><p>能够实现：</p><ul><li><p>异步数据保存</p></li><li><p>订单数据的消息发布</p></li><li><p>分布式事务</p></li><li><p>消息的容错</p></li><li><p>分布式锁</p></li><li><p>分布式会话</p></li><li><p>分库分表</p></li></ul><p>学习思考：</p><ul><li>什么是消息中间件</li><li>什么是协议</li><li>什么是持久化</li><li>消息分发</li><li>消息的高可用</li><li>消息的集群</li><li>消息的容错</li><li>消息的冗余</li></ul><h2 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h2><h3 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h3><p>同步调用的优势：</p><ul><li>时效性强，等待到结果后才返回</li></ul><p>同步调用的问题：</p><ul><li>拓展性差</li><li>性能下降</li><li>级联失败问题</li></ul><p>异步调用包含三个角色：</p><p>消息发送者：投递消息</p><p>消息代理：管理、暂存、转发消息</p><p>消息接收者：接收和处理消息的人</p><p>优势：</p><ul><li><p>解除耦合，挑战性强。消息发送者服务只需要投递消息，不需要修改代码，消息代理投递消息，触发相关服务进行更新。</p></li><li><p>无需等待，性能好</p></li><li><p>故障隔离</p></li><li><p>缓存消息，流量削峰填谷，流量时高时低时可以缓存消息慢慢执行。</p></li></ul><p>问题：</p><ul><li>不能立即得到调用结果，时效性差</li><li>不确定下游服务执行是否成功</li><li>业务安全依赖于Broker的可靠性</li></ul><h3 id="MQ技术选型"><a href="#MQ技术选型" class="headerlink" title="MQ技术选型"></a>MQ技术选型</h3><h4 id="安装RabbitMQ"><a href="#安装RabbitMQ" class="headerlink" title="安装RabbitMQ"></a>安装RabbitMQ</h4><p>publisher:消息发送者</p><p>consumer：消息的消费者</p><p>queue：队列，存储消息</p><p>exchange：交换机，负责路由消息</p><p>docker启动失败failed，解决如下：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl status nftables</span><br><span class="line">sudo apt install nftables -y</span><br><span class="line">sudo systemctl <span class="built_in">start</span> nftables</span><br><span class="line">sudo systemctl enable nftables</span><br><span class="line">sudo update-alternatives --config iptables</span><br><span class="line">sudo systemctl restart docker</span><br><span class="line">systemctl status docker.service</span><br></pre></td></tr></table></figure><p><img src="/2025/04/04/RabbitMQ/image-20250308204221664.png" alt="image-20250308204221664"></p><p>docker运行rabbitmq容器命令：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart <span class="number">71</span>f1d46c7550ee4e07a4d13580681b084fb03e937a19e191f7de5b99aa01e278</span><br></pre></td></tr></table></figure><p>交换机exchange只有负责路由和转发消息，不具有存储消息的能力</p><p>创建队列hello.queue1和hello.queue2，绑定交换机，向默认的amp.fanout交换机发送一条消息。查看消息是否到达hello.queue1和hello.queue2。</p><h3 id="数据隔离"><a href="#数据隔离" class="headerlink" title="数据隔离"></a>数据隔离</h3><p>在RabbitMQ的控制台完成以下操作：</p><ul><li>新建一个用户shalom</li><li>为shalom用户创建一个virtual host</li><li>测试不同virtu host之间的数据隔离现象</li></ul><h3 id="SpringAMQP"><a href="#SpringAMQP" class="headerlink" title="SpringAMQP"></a>SpringAMQP</h3><p><img src="/2025/04/04/RabbitMQ/image-20250307163313283.png" alt="image-20250307163313283"></p><p><img src="/2025/04/04/RabbitMQ/image-20250307163334490.png" alt="image-20250307163334490"></p><p><img src="/2025/04/04/RabbitMQ/image-20250307163355974.png" alt="image-20250307163355974"></p><p><img src="/2025/04/04/RabbitMQ/image-20250307163423718.png" alt="image-20250307163423718"></p><h3 id="work模式"><a href="#work模式" class="headerlink" title="work模式"></a>work模式</h3><ul><li>在RabbitMQ的控制台创建一个队列，名为work.queue</li><li>定义测试方法，在一秒内生成50条消息，发送到work.queue</li><li>在服务中定义两个消息监听者，都监听work.queue队列</li><li>消费者1每秒处理50条消息，消费者2每秒处理5条消息</li></ul><p><img src="/2025/04/04/RabbitMQ/image-20250307164936725.png" alt="image-20250307164936725"></p><p>默认情况下rabbitmq会将消息轮询投递到绑定在一个队列上的每一个消费者，但这并没有考虑到消费者是否已经处理完消息，可能出现消息堆积。因此需要修改application.yml，将preFetch的值修改为1，代表同一时刻最多投递给消费者1个消息。</p><p><img src="/2025/04/04/RabbitMQ/image-20250307164909849.png" alt="image-20250307164909849"></p><h3 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h3><h4 id="Fanout交换机-广播"><a href="#Fanout交换机-广播" class="headerlink" title="Fanout交换机 广播"></a>Fanout交换机 广播</h4><p>会将收到的消息广播到每一个跟其绑定的queue</p><ul><li>在控制台声明fanout.queue1和fanout.queue2</li><li>在控制台中声明交换机shalom.fanout，将两个队列与其绑定</li><li>编写两个消费者方法，分别监听fanout.queue1和fanout.queue2</li><li>编写测试方法，向shalom.fanout发送消息</li></ul><h4 id="Direct交换机-定向"><a href="#Direct交换机-定向" class="headerlink" title="Direct交换机 定向"></a>Direct交换机 定向</h4><p>会将接收到的消息根据规则路由到指定的Queue，定向路由</p><ul><li>每个Queue都与Exchange设置一个BindingKey</li><li>发布者发送消息时，指定消息的RoutingKey</li><li>Exchange将消息路由到BindingKey与消息RoutingKey一致的队列</li></ul><h4 id="Topic交换机-话题"><a href="#Topic交换机-话题" class="headerlink" title="Topic交换机 话题"></a>Topic交换机 话题</h4><p>和direct相似，区别在于routingKey可以是多个单词的列表，以.分隔。Queue和Exchange指定BindingKey时可以使用通配符</p><p>#：代指0个或多个单词</p><p>*：代指一个单词</p><ul><li>在控制台声明队列topic.queue1和topic.queue2</li><li>控制台声明交换机shalom.topic，绑定队列</li><li>编写两个消费者方法，分别监听topic.queue1和topic.queue2</li><li>编写测试方法，利用不同的RoutingKey向shalom.topic发送消息</li></ul><h4 id="java代码声明队列和交换机"><a href="#java代码声明队列和交换机" class="headerlink" title="java代码声明队列和交换机"></a>java代码声明队列和交换机</h4><ul><li>Queue：用于声明队列，可以用工厂QueueBuilder构建</li><li>Exchange：用于声明交换机，可以用工厂类ExchangeBuilder构建</li><li>Binding：用于声明队列和交换机的绑定关系，可以用工厂类BindingBuilder构建</li></ul><p><img src="/2025/04/04/RabbitMQ/image-20250307204550543.png" alt="image-20250307204550543"></p><p>@RabbitListener注解也可以来声明队列和交换机</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">value = @Queue(name = &quot;direct.queue1&quot;),</span></span><br><span class="line"><span class="meta">exchange = @Exchange(name = &quot;shalom.direct&quot;,type = ExchangeType.DIRECT),</span></span><br><span class="line"><span class="meta">key = &#123;&quot;red&quot;,&quot;blue&quot;&#125;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDirectQueue1</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="MQ消息转换器"><a href="#MQ消息转换器" class="headerlink" title="MQ消息转换器"></a>MQ消息转换器</h3><ul><li>声明一个队列，名为object.queue</li><li>编写单元测试，向队列中直接发送一条消息，类型为Map</li><li>在控制台查看消息</li></ul><p>控制台获取到一堆乱码，因为在发送后会对消息进行判断，如果不是object&#x2F;string类型，则会进行默认的JDK序列化，有很大的安全隐患</p><p>建议采用JSON序列化代替默认的JDK序列化</p><ul><li>引入jackson依赖，jackson-databind</li><li>配置MessageConverter类，return Jackson2JsonMessageConverter()</li></ul><h3 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h3><h3 id="消息堆积问题处理"><a href="#消息堆积问题处理" class="headerlink" title="消息堆积问题处理"></a>消息堆积问题处理</h3><h2 id="高级篇"><a href="#高级篇" class="headerlink" title="高级篇"></a>高级篇</h2><p>消息的可靠</p><ul><li>发送者的可靠性</li><li>MQ的可靠性</li><li>消费者的可靠性</li><li>延迟消息</li></ul><h3 id="发送者重连"><a href="#发送者重连" class="headerlink" title="发送者重连"></a>发送者重连</h3><p>生产者重连：有时候由于网络波动可能会出现客户端连接MQ失败的情况，通过配置可以开启连接失败后的重连机制</p><p><img src="/2025/04/04/RabbitMQ/imgimage-20250308173817843.png" alt="image-20250308173817843"></p><p>当网络不稳定的时候，利用重试机制可以有效提高消息发送的成功率。不过SpringAMQP提供的重试机制是阻塞式的，也就是说多次重试等待的过程中，当前线程是被阻塞的，会影响业务性能。</p><p>如果对业务性能有要求，最好禁用重试机制，如果一定使用，合理配置等待时长和重试次数，当然也可以使用异步线程来执行发送消息的代码。</p><h3 id="发送者确认"><a href="#发送者确认" class="headerlink" title="发送者确认"></a>发送者确认</h3><p>Publisher Confirm和Publisher Return两种确认机制。开启确认机制后，在MQ成功收到消息后会返回确认消息给生产者。生产者是异步机制，接收到消费者消息后再处理。</p><p><img src="/2025/04/04/RabbitMQ/image-20250308212116375.png" alt="image-20250308212116375"></p><p>none：关闭confirm机制</p><p>simple：同步阻塞等待MQ的回执消息</p><p>correlated：MQ异步回调方法返回回执消息</p><p>要编写回调函数和测试确认消息</p><h3 id="MQ持久化"><a href="#MQ持久化" class="headerlink" title="MQ持久化"></a>MQ持久化</h3><p>在默认情况下，RabbitMQ会将接收到的消息保存到内存中以降低消息收发的延迟，这样会导致两个问题：</p><ul><li>一旦MQ宕机，内存中的消息会丢失</li><li>内存空间有限，当消费者故障或处理过慢时，会导致消息积压，引发MQ阻塞</li></ul><p>在rabbitMQ3.6以前常用数据持久化，3.6以后使用Lazy Queue来解决这个问题。</p><p><img src="/2025/04/04/RabbitMQ/image-20250308223047431.png" alt="image-20250308223047431"></p><p>交换机和队列的持久化：</p><ul><li><p>transient代表持久化，默认durable是没有持久化的。</p></li><li><p>在spring中创建默认的持久化，就没有控制台这个问题了。</p></li></ul><p>消息持久化：</p><ul><li>在控制台发送消息的时候需要在Properties处加delivery_mode</li></ul><h3 id="LazyQueue"><a href="#LazyQueue" class="headerlink" title="LazyQueue"></a>LazyQueue</h3><p>3.6.0版本开始，新增加了Lazy Queue，也就是惰性队列</p><ul><li>接收到消息后直接存入磁盘而非内存（内存中只保留最近的数据，默认2048条）</li><li>消费者要消费消息时会从磁盘中读取并加载到内存</li><li>支持数百万条消息存储</li></ul><p>从3.12版本后，所有队列都是Lazy Queue模式，无法更改。</p><p><img src="/2025/04/04/RabbitMQ/image-20250308231454645.png" alt="image-20250308231454645"></p><h3 id="消费者确认机制"><a href="#消费者确认机制" class="headerlink" title="消费者确认机制"></a>消费者确认机制</h3><p>为了确认消费者是否成功处理消息，RabbitMQ提供了消费者确认机制。当消费者处理消息结束后，向RabbitMQ发送一个回执，告知RabbitMQ自己消息处理状态</p><ul><li>ack：成功处理消息。从队列中删除该消息</li><li>nack：消息处理失败，再次投递消息</li><li>reject：消息处理失败并拒绝该消息，从队列中删除该消息</li></ul><p>SpringAMQP已经实现了消息确认功能，允许我们通过配置文件选择ACK处理方式，</p><p>acknowledge-mode有三种方式：</p><ul><li>none：不处理。消息投递后离开ack，不安全</li><li>manual：手动模式。自己在业务代码中调用api，发送ack或reject，更灵活</li><li>auto：自动模式。SpringAMQP利用AOP对我们的消息处理逻辑做了环绕增强，业务正常执行时则自动返回ack</li></ul><h3 id="失败重试"><a href="#失败重试" class="headerlink" title="失败重试"></a>失败重试</h3><p>当消费者出现异常后，消息会不断requeue到队列，再重新发送给消费者，再次异常，再次requeue，无限循环，导致mq的消息处理飙升，带来不必要的压力。</p><p>可以利用spring的retry机制，在消费者出现异常时利用本地重试，而不是无限制的requeue到mq队列。</p><p>在开启重试模式后，重试次数耗尽，如果消息依然失败，则需要有MessageRecoverer接口来处理，包含三种不同实现</p><ul><li>RejectAndDontRequeueRecoverer：重试耗尽后，直接reject，丢弃消息。默认方式</li><li>ImmediateRequeueMessageRecoverer：重试耗尽后，返回nack，消息重新入队</li><li>RepublishMessageRecoverer：重试耗尽后，将失败消息投递到指定的交换机</li></ul><h3 id="业务幂等"><a href="#业务幂等" class="headerlink" title="业务幂等"></a>业务幂等</h3><p>幂等是一个数学概念，用函数表达式来描述。在程序开发中，指的是同一个业务执行一次或多次对业务的状态影响是一致的</p><h5 id="唯一id"><a href="#唯一id" class="headerlink" title="唯一id"></a>唯一id</h5><p>给每个消息设置一个唯一id，利用id区分是否是重复消息：</p><ol><li>每一条信息产生唯一一个id，与消息一起投递给消费者</li><li>消费者接收到消息后，处理自己的业务，业务处理成功后将消息ID保存到数据库</li><li>如果下次又收到相同消息，去数据库查询判断是否存在，存在则为重复消息放弃处理。</li></ol><p>如何保证支付服务与交易服务之间的订单状态一致性？</p><ul><li>支付服务会在用户支付成功后利用MQ消息通知交易服务，完成订单状态同步</li><li>为了保证MQ消息的可靠性，采用生产者确认机制、消费者确认机制和消费者失败重试，确保消息投递和处理的可靠性。同时开启MQ数据持久化，使用Lazy Queue，避免服务宕机导致消息丢失</li><li>最后对交易服务更新订单状态是作业务幂等判断，避免因消息重复消费导致订单状态异常。</li></ul><p>如果交易服务消息处理失败，有没有兜底方案？</p><ul><li>在交易服务设置定时任务，定期查询订单支付状态。这样即便MQ通知失败，还可利用定时任务作为兜底，确保订单支付状态的最终一致性。</li></ul><h3 id="延迟消息"><a href="#延迟消息" class="headerlink" title="延迟消息"></a>延迟消息</h3><p>生产者发送一个消息后，消费者不会立刻收到消息，而是在指定时间之后才收到消息。</p><p>秒杀商品场景，当下单不付款时不会将库存减一，而是付款后才会减一。</p><p>redis也有过期设置</p><h4 id="死信交换机"><a href="#死信交换机" class="headerlink" title="死信交换机"></a>死信交换机</h4><p>当一个队列中的消息满足下列情况之一时，就会成为死信</p><ul><li>消费者使用basic.reject或basic.nack声明消费失败，并且消息的requeue参数设置为false</li><li>消息是一个过期消息（达到了队列或消息本身设置的过期时间），超时无人消费</li><li>要投递的队列消息堆积满了，最早的消息可能成为死信</li></ul><p>如果队列通过dead-letter-exchange属性指定了一个交换机，那么该队列中的死信就会投递到这个交换机中，这个交换机成为死信交换机。</p><p>官方是用来兜底的，并不是用来做延迟的。</p><h4 id="延迟消息插件"><a href="#延迟消息插件" class="headerlink" title="延迟消息插件"></a>延迟消息插件</h4><p>delay关键字</p><p>通过docker挂在rabbitmq会自动导出延迟消息的插件，挂载本地则没有</p><h4 id="取消超时订单"><a href="#取消超时订单" class="headerlink" title="取消超时订单"></a>取消超时订单</h4><p>设置30分钟后检测订单支付状态实现起来简单，但会存在两个问题：</p><ul><li>如果并发较高，30分钟可能堆积消息过多，对MQ压力大</li><li>大多数订单在下单后1分钟内就会支付，但是却需要在MQ内等待30分钟，浪费资源</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis笔记</title>
      <link href="/2024/07/02/Redis%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/07/02/Redis%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MyySQL笔记</title>
      <link href="/2024/07/02/MyySQL%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/07/02/MyySQL%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java进阶</title>
      <link href="/2024/07/02/Java%E8%BF%9B%E9%98%B6/"/>
      <url>/2024/07/02/Java%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java笔记</title>
      <link href="/2024/07/02/Java%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/07/02/Java%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="面向对象编程（基础）"><a href="#面向对象编程（基础）" class="headerlink" title="面向对象编程（基础）"></a>面向对象编程（基础）</h2><h3 id="1、类与对象"><a href="#1、类与对象" class="headerlink" title="1、类与对象"></a>1、类与对象</h3><blockquote><p>1、使用变量来管理不利于数据的管理，</p><p>2、数组难以体现数据类型，</p><p>3、不能体现行为信息。</p><p>故引出类与对象（OOP）的概念</p></blockquote><p>一个程序就是一个世界，有很多事物（对象[属性，行为]）</p><p>类是一种定义的数据类型，可以是Java定义的也可以是自定义的。</p><p>Java定义例如：int，String</p><p>对象就是一个具体的实例。</p><p>例如类是设计图纸，对象就是根据类具体出的实物。（实物的属性行为，尺寸、颜色等根据设计图纸进行限制，但需要跟设计图纸中的基本保持一致）</p><h3 id="2、使用面向对象的方式来创建类"><a href="#2、使用面向对象的方式来创建类" class="headerlink" title="2、使用面向对象的方式来创建类"></a>2、使用面向对象的方式来创建类</h3><p>创建类的举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>&#123;</span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    String color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例化对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//使用变量</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">cat1Name</span> <span class="operator">=</span> <span class="string">&quot;小白&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">cat2Name</span> <span class="operator">=</span> <span class="string">&quot;小花&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">cat1Age</span> <span class="operator">=</span> <span class="number">18</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cat2Age</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">cat1Color</span> <span class="operator">=</span> <span class="string">&quot;白色&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">cat2Color</span> <span class="operator">=</span> <span class="string">&quot;花色&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//oop实例化一只猫</span></span><br><span class="line">        <span class="comment">//1、new Cat（）创建一只猫</span></span><br><span class="line">        <span class="comment">//2、将创建的猫赋值给cat1、cat2</span></span><br><span class="line">        <span class="type">Cat</span> <span class="variable">cat1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        cat1.age = <span class="number">18</span>;</span><br><span class="line">        cat1.color = cat1Color;</span><br><span class="line">        cat1.name = cat1Name;</span><br><span class="line">        <span class="type">Cat</span> <span class="variable">cat2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        cat2.age = <span class="number">100</span>;</span><br><span class="line">        cat2.color = cat2Color;</span><br><span class="line">        cat2.name = cat2Name;</span><br><span class="line">        <span class="type">Cat</span> <span class="variable">cat3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="对象在内存中存在形式："><a href="#对象在内存中存在形式：" class="headerlink" title="对象在内存中存在形式："></a>对象在内存中存在形式：</h4><p><img src="/2024/07/02/Java%E7%AC%94%E8%AE%B0/桌面\笔记\HexoBlog\source_posts\img\image-20240703112739089.png"></p><p>​如果数据类型是String，则会将信息存到内存中的方法区中，在堆中仅显示方法区地址。如果是int这种基本数据类型则会直接存入堆中的对应位置。</p><blockquote><p>1、属性的定义语法同变量，示例：访问修饰符 属性类型 属性名。</p><p>2、属性的定义类型可以为任意类型，包含基本类型或引用类型。</p><p>3、属性如果不赋值，有默认值，规则和数组一致。</p></blockquote><h4 id="类和对象的内存分配机制（重要）"><a href="#类和对象的内存分配机制（重要）" class="headerlink" title="类和对象的内存分配机制（重要）"></a>类和对象的内存分配机制（重要）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">      p1.age = <span class="number">10</span>;</span><br><span class="line">      p1.name = <span class="string">&quot;xiaoming&quot;</span>;</span><br><span class="line">      <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> p1; <span class="comment">//把p1的值赋给p2</span></span><br><span class="line">      System.out.println(p2.age);</span><br></pre></td></tr></table></figure><p>第一行代码首先要在方法区进行加载，加载Person的信息</p><p>​new在堆里开辟空间，属性是默认值</p><p>栈中的p1指向堆中的指定空间</p><p>然后将堆中的age赋值为10</p><p>string常量池中name赋值为“xiaoming”，堆中存常量池的地址</p><p>然后在栈中创建的p2的地址与p1的地址相同，p2指向堆中p1所在的位置</p><p><img src="/2024/07/02/Java%E7%AC%94%E8%AE%B0/image-20240704103759226.png" alt="image-20240704103759226"></p><p>p201练习值得反复看！</p><h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Method01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        person.speak();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//成员方法</span></span><br><span class="line">    <span class="comment">//&#123;&#125;是方法体，可以写代码</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">speak</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是一个好人&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法的调用机制分析"><a href="#方法的调用机制分析" class="headerlink" title="方法的调用机制分析"></a>方法的调用机制分析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">      person.speak();</span><br><span class="line">      <span class="type">int</span> <span class="variable">resultRes</span> <span class="operator">=</span> person.getSum(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line">      System.out.println(resultRes);</span><br><span class="line"></span><br><span class="line">String name;</span><br><span class="line">      <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//成员方法</span></span><br><span class="line">      <span class="comment">//&#123;&#125;是方法体，可以写代码</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">speak</span><span class="params">()</span>&#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;我是一个好人&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> numberA, <span class="type">int</span> numberB)</span>&#123;</span><br><span class="line">          <span class="keyword">return</span> numberA + numberB;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>首先在栈创建一个空间，在堆中有一个相应的对象产生。</p><p>第二行代码，先执行getSum，然后在栈中产生一个独立的空间，numberA-&gt;10,numberB-&gt;20。然后通过地址定位到对象类的对应方法进行计算。然后reture结果给栈中的空间，return之后独立的空间就会消失，当main栈执行完毕后也会消失，整个程序退出。</p><p><img src="/2024/07/02/Java%E7%AC%94%E8%AE%B0/image-20240704110522542.png" alt="image-20240704110522542"></p><h4 id="方法的传参机制"><a href="#方法的传参机制" class="headerlink" title="方法的传参机制"></a>方法的传参机制</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Swap</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">        <span class="type">AA</span> <span class="variable">aa</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AA</span>();</span><br><span class="line">        aa.Swap(a,b);</span><br><span class="line">        System.out.println(<span class="string">&quot;a = &quot;</span>+ a + <span class="string">&quot; b = &quot;</span> + b );</span><br><span class="line">        <span class="comment">//上面这句话输出a=10，b=20</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Swap</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;</span><br><span class="line">        System.out.println(<span class="string">&quot;a=&quot;</span>+a+<span class="string">&quot; b=&quot;</span>+b);<span class="comment">//这句话a输出20，b10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​主方法将a和b传给AA中的Swap方法，而Swap中发生的变化不影响主方法中的变量a和b。因为main和AA中的Swap属于两个独立的栈空间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodParameter02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        b.test100(arr);</span><br><span class="line">        System.out.println(<span class="string">&quot;main的arr&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.println(arr[i]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//B类中编写一个方法test100</span></span><br><span class="line"><span class="comment">//可以接收一个数组，在方法中修改该数组，看原来的数组是否变化</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test100</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="number">231</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">            System.out.println(arr[i] + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">231</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">main的arr</span><br><span class="line"><span class="number">231</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"></span><br><span class="line">进程已结束，退出代码为 <span class="number">0</span></span><br></pre></td></tr></table></figure><p>​当使用数组引用时，该方法将对原始数组引用，这意味方法对数组做的任何更改都会影响原始数据。引用数据类型传递的是地址。</p><blockquote><p>java中的数据类型主要分为两类，基本数据类型和引用数据类型，引用数据类型包括：类、接口和数组。</p></blockquote><p>p213值得反复看！</p><p><img src="/2024/07/02/Java%E7%AC%94%E8%AE%B0/d71964489a56c83d22b87b9f4a5ee8e5.png"></p><blockquote><p>克隆方法和直接使用方法在内存中的区别。</p></blockquote><blockquote><p>递归调用本质就是在栈中不断开辟新的空间，不断的进栈和出栈。</p><p>方法的重载就是同一个方法名但不同的形参。返回类型不同并不构成方法的重载。</p></blockquote><h4 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h4><blockquote><p>java允许将同一个类中多个同名同功能但参数个数不同的方法，封装成一个方法。就可以通过可变参数实现。</p><p>访问修饰符 返回类型 方法名（数据类型… 形参名）{</p><p>}</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OverloadDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">OverloadDemo1</span> <span class="variable">ovl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OverloadDemo1</span>();</span><br><span class="line">        ovl.sum(<span class="number">1</span>,<span class="number">22</span>,<span class="number">33</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OverloadDemo1</span> &#123;</span><br><span class="line">    <span class="comment">//严格遵守可变参数的规则</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span>... nums)</span>&#123;</span><br><span class="line">        System.out.println(nums.length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可变参数的实参可以为0个或任意多个</p><p>可变参数的实参可以为数组</p><p>可变参数的本质就是数组</p><p>1、可变参数可以和普通类型的参数一起放在形参列表，但必须保证可变参数在最后</p><p>2、一个形参列表中只能出现一个可变参数。</p></blockquote><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><blockquote><p>1、在Java编程中，主要的变量就是属性和局部变量</p><p>2、局部变量一般是指在成员方法中定义的变量。</p><p>3、java中的作用域分类</p><p>​全局变量：也就是属性，作用域为整个类体。</p><p>​局部变量：也就是除了属性之外的其他变量，作用域为定义它的代码块中</p><p>4、全局变量也可以不赋值，直接使用，因为有默认值，局部变量必须赋值后才能使用，因为没有默认值。</p></blockquote><h3 id="四种访问修饰符"><a href="#四种访问修饰符" class="headerlink" title="四种访问修饰符"></a>四种访问修饰符</h3><h4 id="public"><a href="#public" class="headerlink" title="public"></a>public</h4><h4 id="protected"><a href="#protected" class="headerlink" title="protected"></a>protected</h4><h4 id="默认"><a href="#默认" class="headerlink" title="默认"></a>默认</h4><h4 id="private"><a href="#private" class="headerlink" title="private"></a>private</h4>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Notes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法Java</title>
      <link href="/2024/07/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95Java-1/"/>
      <url>/2024/07/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95Java-1/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构与算法Java"><a href="#数据结构与算法Java" class="headerlink" title="数据结构与算法Java"></a>数据结构与算法Java</h1><h2 id="1、数据结构与算法内容介绍"><a href="#1、数据结构与算法内容介绍" class="headerlink" title="1、数据结构与算法内容介绍"></a>1、数据结构与算法内容介绍</h2><h3 id="1-1内容介绍"><a href="#1-1内容介绍" class="headerlink" title="1.1内容介绍"></a>1.1内容介绍</h3><h4 id="1-1-1常见面试算法题"><a href="#1-1-1常见面试算法题" class="headerlink" title="1.1.1常见面试算法题"></a>1.1.1常见面试算法题</h4><h2 id="2、线性结构与非线性结构"><a href="#2、线性结构与非线性结构" class="headerlink" title="2、线性结构与非线性结构"></a>2、线性结构与非线性结构</h2><h3 id="2-1线性结构"><a href="#2-1线性结构" class="headerlink" title="2.1线性结构"></a>2.1线性结构</h3><blockquote><p>1、线性结构作为最常用的数据结构，其特点是数据元素之间存在一对一的线性关系</p><p>2、线性结构有两种不同的存储结构，即顺序存储结构（数组）和链式存储结构（链表）。顺序存储的线性表称为顺序表，顺序表中的存储元素是连续的</p><p>3、链式存储的线性表称为链表，链表中的存储元素不一定连续的，元素节点中存放数据元素以及相邻元素的地址</p><p>4、线性结构常见的有：数组、队列、链表和栈。</p></blockquote><h3 id="2-2非线性结构"><a href="#2-2非线性结构" class="headerlink" title="2.2非线性结构"></a>2.2非线性结构</h3><blockquote><p>非线性结构包括：二维数组，多维数组，广义表，树结构，图结构</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/06/30/hello-world/"/>
      <url>/2024/06/30/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
